%ifndef MAC_CPU_MAC
%define MAC_CPU_MAC


; Read opcode data, maintain integrity of the prefetch queue

%macro fetchwopcode_inc_pos_prefetch 0
%ifdef PC_PTR
		movzx	edx, word [prefetch_word]
		push	edx
		mov	dh, byte [2 + ecx]
		mov	dl, byte [3 + ecx]
		mov	word [prefetch_word], dx
		pop	edx
%else
		movzx	edx, word [prefetch_word]
		push	edx
		add	ecx, 2
		fetchw
		mov	word [prefetch_word], dx
		sub	ecx, 2
		pop	edx
%endif
%endmacro

%macro fetchwopcode_normal 0
%ifdef PC_PTR
		mov	edx, dword [ecx - 2]
		bswap	edx
		and	edx, 0ffffh
;		xor	edx, edx
;		mov	dh, byte [ecx]
;		mov	dl, byte [1 + ecx]
%else
		fetchw
%endif
%endmacro

%macro fetchwopcode_inc_pos 0
%ifdef PREFETCH
		fetchwopcode_inc_pos_prefetch
%else
		fetchwopcode_normal
%endif
%endmacro

%macro fetchwopcode_keep_pos_prefetch 0
		movzx	edx, word [prefetch_word]
%endmacro

%macro fetchwopcode_keep_pos 0
%ifdef PREFETCH
		fetchwopcode_keep_pos_prefetch
%else
		fetchwopcode_normal
%endif
%endmacro

%macro fetchlopcode_inc_pos_prefetch 0
%ifdef PC_PTR
		mov	dx, word [prefetch_word]
		shl	edx, 16
		push	ecx
		push	edx
		mov	edx, dword [2 + ecx]
		bswap	edx
		mov	word [prefetch_word], dx
		shr	edx, 16
		pop	ecx
		or	edx, ecx
		pop	ecx
%else
		mov	dx, word [prefetch_word]
		shl	edx, 16
		push	ecx
		push	edx
		add	ecx, 2
		fetchl
		mov	word [prefetch_word], dx
		shr	edx, 16
		pop	ecx
		or	edx, ecx
		pop	ecx
%endif
%endmacro

%macro fetchlopcode_normal 0
%ifdef PC_PTR
		mov	edx, dword [ecx]
		bswap	edx
%else
		fetchl
%endif
%endmacro

%macro fetchlopcode_inc_pos 0
%ifdef PREFETCH
		fetchlopcode_inc_pos_prefetch
%else
		fetchlopcode_normal
%endif
%endmacro

%macro fetchlopcode_keep_pos_prefetch 0
%ifdef PC_PTR
		mov	dx, word [prefetch_word]
		shl	edx, 16
		mov	dh, byte [2 + ecx]
		mov	dl, byte [3 + ecx]
%else
		mov	dx, word [prefetch_word]
		shl	edx, 16
		push	ecx
		push	edx
		add	ecx, 2
		fetchw
		and	edx, 0ffffh
		pop	ecx
		or	edx, ecx
		pop	ecx
%endif
%endmacro


%macro fetchlopcode_keep_pos 0
%ifdef PREFETCH
		fetchlopcode_keep_pos_prefetch
%else
		fetchlopcode_normal
%endif
%endmacro


; Execute one instruction, no trace test

%macro EXEC_NEXT_68K 0
		mov	ecx, dword [pc]
		push	dword %%fin

		fetchwopcode_inc_pos

        	mov	edi, dword [cpu_next]
		shl	edx, 5

		lea	esi, [2 + ecx]
        	mov	dword [curcycle], edi

        	mov	ebx, dword [bus_cycle_to_xpos + edi]
		shr	edi, 2

        	mov	eax, dword [bus_cycle_to_ypos + 2*edi]
		
		and	ebx, 0ffh
		and	eax, 01ffh
        	lea	edi, [t + edx]
		
		mov	dword [graph_raster_x], ebx
        	mov	dword [graph_raster_y], eax

		jmp	dword [edi]

		FALIGN32

%%fin:		mov	dword [pc], esi
%endmacro

; Execute one instruction, with trace test

%macro EXEC_NEXT_68K_TRACE 0
		mov	ecx, dword [pc]
		push	dword %%fin

		fetchwopcode_inc_pos                            

		mov	edi, dword [cpu_next]
		shl	edx, 5

		lea	esi, [2 + ecx]
		mov	dword [curcycle], edi

        	mov	ebx, dword [bus_cycle_to_xpos + edi]
		shr	edi, 2
        	mov	eax, dword [bus_cycle_to_ypos + 2*edi]
		
		and	ebx, 0ffh
		and	eax, 01ffh

        	lea	edi, [t + edx]
		
        	mov	dword [graph_raster_x], ebx
        	mov	dword [graph_raster_y], eax

		test	byte [sr + 1], 0c0h
		jnz	near tracebit_handler

		jmp	dword [edi]

		FALIGN32

%%fin:		mov	dword [pc], esi
%endmacro


; Map proper PC to pointer to the memory used
; or blank if this is not defined
; PROPER_PC must be a register, and will contain changed pc on exit
; pcbaseadr will also be set to the base of the type of memory
; for easy translation back (+ AMiga base for that memory )
; Used for absolute jumps like irq, exceptions and jmp/jsr 

; PROPER_PC can not be eax


%macro PC_TO_PTR 1 ; PROPER_PC
%ifdef PC_PTR
		and	%1, 0ffffffh
		push	eax
		mov	eax, %1
		shr	eax, 16
		mov	eax, dword [memory_bank_pointer + 4*eax]
		test	eax, eax
		jz	near cpu_pc_in_unmapped_mem
		add	%1, eax
		mov	dword [pcbaseadr], eax
		pop	eax
%endif
%endmacro


; Translate pointer back to proper pc

%macro PTR_TO_PC 1   ; SRC
%ifdef PC_PTR
		sub	%1, dword [pcbaseadr]
%endif
%endmacro


;==============================================================================
; Call 64-bit division in 68030ini.c
;
; Assembly calling convention:
; In:  eax - extension word
;      edx - operand
; Out: eax - result
;==============================================================================

%macro I320_CWRAP 0
		CCALLCONV_IN_EAXEDX
		call	i320_C
		CCALLCONV_OUT_EAX	2
%endmacro



%endif
